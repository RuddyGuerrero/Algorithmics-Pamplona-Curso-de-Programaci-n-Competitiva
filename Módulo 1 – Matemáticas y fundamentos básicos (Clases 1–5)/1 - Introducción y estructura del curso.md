# üìò Clase 1 ‚Äì Introducci√≥n y Fundamentos

## üéØ Objetivos de la clase

- Conocer la **estructura del curso**.  
- Entender la **complejidad computacional** y la notaci√≥n **Big-O** (tiempo de ejecuci√≥n).  
- Entender la **complejidad espacial** (uso de memoria).
- Estudiar **entrada y salida b√°sica**.

## ‚è±Ô∏è Complejidad computacional (Notaci√≥n Big-O)

La **complejidad computacional** mide cu√°ntas operaciones realiza un algoritmo en funci√≥n del tama√±o de la entrada `n`.  
Se utiliza la **notaci√≥n Big-O** para describir el **peor caso**, es decir, el m√°ximo n√∫mero de pasos que puede tomar un algoritmo.

### Complejidades comunes

| Algoritmo / Operaci√≥n           | Big-O       | Descripci√≥n breve                                | Valores de `n` aproximados |
|--------------------------------|------------|-------------------------------------------------|---------------------------|
| Acceso a un elemento            | O(1)       | Acceder a un √≠ndice de un arreglo o lista       | Hasta $10^8$                |
| B√∫squeda lineal                 | O(n)       | Recorre todos los elementos de una lista       | Hasta  $10^7$                   |
| B√∫squeda binaria                | O(log n)   | Divide el problema por la mitad cada vez       | Hasta  $10^{18}$   o m√°s          |
| Ordenamiento r√°pido (Quicksort) | O(n log n) | Algoritmo eficiente de ordenaci√≥n              | Hasta  $10^6$                  |
| Fuerza bruta / pares            | O(n¬≤)      | Compara todos los pares posibles               | Hasta  $10^3$   ‚Äì  $10^4$             |
| Exponencial simple              | O(2‚Åø)      | Algoritmos que generan todas las combinaciones de elementos | Hasta 20     |
| Fuerza bruta permutaciones      | O(n!)      | Generar todas las permutaciones de `n` elementos| Hasta 10                  |

## C√≥mo calcular la complejidad de un algoritmo

  Observa el bloque de c√≥digo que m√°s se repite o hace m√°s trabajo. Ese bloque domina la complejidad.

1. **Operaciones con coste O(1)**  
  
    Algunas **operaciones b√°sicas tienen coste O(1)** (tiempo constante), es decir, no dependen de `n`:

   - Asignaciones simples: `x = 5`
   - Sumas, restas, multiplicaciones y divisiones simples: `x + y`
   - Comparaciones: `x > y`
   - Acceso a un elemento de una lista: `arr[i]`
   - Llamadas a funciones que son O(1) por definici√≥n

       **Ejemplo:**

       ```python
       x = 5        # O(1)
       y = x + 2    # O(1)
       print(y)     # O(1)
       ```

2. **Sumar bucles anidados**  
   - Cada bucle anidado multiplica las operaciones:

   ```python
   for i in range(n):      # O(n)
       for j in range(n):  # O(n)
           print(i, j)     # O(1)
   # Complejidad total: O(n¬≤)
    ```

3. **Ignorar constantes y t√©rminos menores**  
   - Al calcular la complejidad, **no importa multiplicar por constantes ni sumar t√©rminos menores**.  
   - Ejemplos:  
     - O(3n + 5) ‚Üí O(n)  
     - O(n¬≤ + n) ‚Üí O(n¬≤)

4. **Calcular complejidades de recursividad ü§Ø**  
   - No entraremos en detalle en este curso, pero en recursi√≥n se usan **ecuaciones de recurrencia** para estimar el n√∫mero de operaciones.  
   - La idea es ver **cu√°ntas veces se llama la funci√≥n** y cu√°nto trabajo hace cada llamada.  
   - Ejemplo t√≠pico: mergesort ‚Üí O(n log n), Fibonacci recursivo simple ‚Üí O(2‚Åø)

## Ejemplo pr√°ctico: combinaci√≥n de bucles y condiciones

```python
def ejemplo_complejidad(arr):
    total = 0
    # Ciclo simple con varios if
    for x in arr:          # Se ejecuta n veces ‚Üí O(n)
        if x % 2 == 0:
            total += x
        if x % 3 == 0:
            total += 2*x
        if x % 5 == 0:
            total += 3*x
    # Dos ciclos for anidados
    n = len(arr)
    for i in range(n):    # O(n)
        for j in range(n):# O(n)
            total += i*j  # O(1)
    return total

# Complejidad total:
# Primer for: O(n)
# Segundo for anidado: O(n¬≤)
# Total: O(n + n¬≤) ‚Üí O(n¬≤)
```

## üíæ Complejidad espacial

La **complejidad espacial** mide **cu√°nta memoria utiliza un algoritmo** en funci√≥n del tama√±o de la entrada `n`.  
Es tan importante como la complejidad temporal, sobre todo en problemas donde la memoria es limitada.

### Factores principales que afectan la complejidad espacial

- Variables simples (enteros, floats, booleanos) ‚Üí O(1)  
- Arreglos o listas de tama√±o `n` ‚Üí O(n)  
- Matrices de tama√±o n √ó m ‚Üí O(n*m)  
- Estructuras de datos adicionales (pilas, colas, diccionarios) ‚Üí depende del n√∫mero de elementos  
- Funciones recursivas ‚Üí la pila de llamadas tambi√©n consume memoria  

> **Nota:** La complejidad espacial **no siempre coincide con la temporal**. Por ejemplo, algunos algoritmos r√°pidos usan m√°s memoria para almacenar estructuras auxiliares.

### Ejemplo: calcular memoria de una matriz n x n (te√≥rico)

Supongamos que queremos crear una **matriz de enteros** de tama√±o `n √ó n` y que cada entero ocupa **32 bytes**.

```python
n = 1000            # tama√±o de la matriz
matriz = [[0 for _ in range(n)] for _ in range(n)] # Crear matriz
```

$$
\text{Memoria total (bytes)} = n \times n \times \text{tama√±oEntero}
$$

- `n √ó n` ‚Üí n√∫mero total de elementos
- `tama√±o_entero` ‚Üí memoria de cada entero (32 bytes aproximadamente)

### 2. Convertir a megabytes (MB)

$$
\text{Memoria (MB)} = \frac{\text{Memoria total (bytes)}}{1024 \times 1024}
$$

- 1 KB = 1024 bytes  
- 1 MB = 1024 KB = 1024 √ó 1024 bytes

### 3. Ejemplo con n = 1000

- N√∫mero de elementos: $1000 √ó 1000 = 1,000,000$  
- Memoria en bytes: $1,000,000 √ó 32 = 32,000,000$ bytes  
- Memoria en MB: $32,000,000 √∑ (1024 √ó 1024) ‚âà 30.52$ MB

> **Nota:** Este c√°lculo es te√≥rico. En Python, los enteros son objetos y usan m√°s memoria debido al overhead.

## üñ•Ô∏è Entrada y salida en Python

### 1. Leer un solo n√∫mero

```python
# Leer un entero
x = int(input())
print("N√∫mero le√≠do:", x)
```

### 2. Leer una lista de n√∫meros en una sola l√≠nea separada por espacios

```python
# Entrada: "1 2 3 4 5"
arr = list(map(int, input().split()))
print("Lista le√≠da:", arr)
```

### 3. Leer una matriz `n x m`

```python
n = int(input()) # N√∫mero de filas
m = int(input()) # N√∫mero de columnas:

matriz = []
for _ in range(n):
    fila = list(map(int, input().split()))
    matriz.append(fila)

print("Matriz le√≠da:")
for fila in matriz:
    print(fila)
```

### 4. Leer `n` n√∫meros cuando `n` est√° dado

```python
n = int(input("N√∫mero de elementos: "))
numeros = []
for _ in range(n):
    numeros.append(int(input()))

print("N√∫meros le√≠dos:", numeros)
```

### 5. Leer hasta el final de la entrada (desconocido)

```python
import sys

numeros = []
for linea in sys.stdin:
    print("Le√≠:", line.strip())
```

### üìù [Problemas: Clase 1 ‚Äì Introducci√≥n y Fundamentos](https://www.hackerrank.com/clase-1-introduccion-y-fundamentos)

## Soluciones a los problemas

### [Hola Algorithmic](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/hola-algorithmic)

```python
# imprime el saludo en la consola
print("Hola, Algorithmic!")
```

### [¬øN√∫mero Par o Impar?](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/numero-par-o-impar-1)

```python
# leemos un n√∫mero y lo convertimos a entero
a = int(input())
# si el n√∫mero es impar
if a % 2 == 1:
    print("Odd")  # mostramos "Odd"
else:
    print("Even")  # si no, es par y mostramos "Even"
```

### [M√°ximo de Dos Enteros](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/maximo-de-dos-enteros)

```python
# leemos varios n√∫meros separados por espacios, los convertimos a enteros y mostramos el mayor
print(max(map(int, input().split())))
```

### [Contar Cuadrados Perfectos en una Lista](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/contar-cuadrados-perfectos-en-una-lista)

```python
# leemos una lista de n√∫meros enteros separados por espacios
arr = list(map(int, input().split()))
count = 0  # contador de n√∫meros que son cuadrados perfectos
for num in arr:
    if num >= 0:
        # calculamos la ra√≠z entera y comprobamos si es cuadrado perfecto
        raiz = int(num**(1/2))
        if raiz * raiz == num:  # Comprobamos si es un cuadrado perfecto
            count += 1
# mostramos la cantidad de cuadrados perfectos
print(count)
```

#### Otra soluci√≥n utilizando compresi√≥n de listas

```python
# leemos n√∫meros separados por espacios y contamos cu√°ntos son cuadrados perfectos
print(sum(
    1 for x in input().split() 
    if int(int(x)**(1/2)) * int(int(x)**(1/2)) == int(x)  # comprobamos si x es cuadrado perfecto
))
```

### [El mensaje secreto](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/el-mensaje-secreto)

```python
def descifrar_mensaje(linea):
    resultado = []
    vocales = "aeiouAEIOU"
    for c in linea:
        if c in vocales:
            continue  # saltamos las vocales
        elif c.isalpha():  
            resultado.append(c.upper())  # convertimos consonantes a may√∫scula
        elif c == ' ':
            resultado.append('_')  # reemplazamos espacios por guiones bajos
        else:
            resultado.append(c)  # otros caracteres los dejamos igual
    return ''.join(resultado)
# leemos hasta que se ingrese '#'
while True:
    linea = input() # leemos la linea de entrada
    if linea == '#': # si es '#' terminamos el ciclo
        break
    print(descifrar_mensaje(linea))
```

### [N√∫mero M√°s Frecuente en una Lista](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/numero-mas-frecuente-en-una-lista)

```python
# leemos una lista de n√∫meros separados por espacios
a = list(map(int, input().split()))
d = {}       # diccionario para contar cu√°ntas veces aparece cada n√∫mero
ma = -1      # mayor cantidad de repeticiones encontrada
sol = 0      # n√∫mero con mayor frecuencia (y menor en caso de empate)
for x in a:
    if x in d:
        d[x] += 1
    else:
        d[x] = 1
    # actualizamos la soluci√≥n si encontramos m√°s repeticiones
    if ma < d[x]:
        ma = d[x]
        sol = x
    # si hay empate en repeticiones, elegimos el menor n√∫mero
    elif ma == d[x] and x < sol:
        sol = x
print(sol)  # mostramos el n√∫mero m√°s frecuente
```

### [Suma de Todos los Elementos en una Matriz](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/suma-de-todos-los-elementos-en-una-matriz)

```python
# leemos la cantidad de filas y columnas
n = int(input())
m = int(input())
su = 0  # acumulador de la suma
for i in range(n):
    # leemos una fila de n√∫meros y sumamos sus valores
    su += sum(map(int, input().split()))
print(su)  # mostramos la suma total
```

### [Batalla de Soldados de Juguete](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/batalla-de-soldados-de-juguete)

#### Explicaci√≥n de la soluci√≥n

- Ordenamos tus soldados (`a`) y los del otro ni√±o (`b`) de menor a mayor.  
- Usamos un puntero `p` para recorrer los soldados del otro ni√±o.  
- Para cada uno de tus soldados (en orden creciente):  
  - Si tu soldado es **m√°s fuerte** que el soldado actual del otro ni√±o (`x > b[p]`), ganamos la batalla.  
  - Avanzamos `p` al siguiente soldado del otro ni√±o para la pr√≥xima comparaci√≥n.  
- Esta estrategia asegura **maximizar el n√∫mero de victorias** porque siempre usamos el soldado m√°s d√©bil posible que a√∫n pueda ganar.  
- Finalmente, `sol` contendr√° el **n√∫mero m√°ximo de victorias** que puedes lograr.

```python
# leemos la cantidad de soldados
n = int(input())
# leemos las fuerzas de tus soldados y del otro ni√±o
a = list(map(int, input().split()))
b = list(map(int, input().split()))
# ordenamos ambos conjuntos de soldados de menor a mayor
a.sort()
b.sort()
p = 0       # puntero para recorrer los soldados del otro ni√±o
sol = 0     # contador de victorias
# recorremos tus soldados
for x in a:
    if x > b[p]:  # si tu soldado es m√°s fuerte que el actual del otro ni√±o
        sol += 1  # ganamos la batalla
        p += 1    # pasamos al siguiente soldado del otro ni√±o
print(sol)  # mostramos el n√∫mero m√°ximo de victorias
```

### [Columna M√°xima por Fila](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/columna-maxima-por-fila)

#### Idea de la soluci√≥n

- Para **maximizar la suma**, en cada fila basta con elegir el **elemento m√°s grande**.  
- Recorremos cada fila, encontramos su m√°ximo y lo sumamos al total.  
- Al final, `sol` contendr√° la **suma m√°xima posible** siguiendo la regla de elegir un elemento por fila.  

```python
# leemos la cantidad de filas (n) y columnas (m)
n, m = map(int, input().split())
# leemos la matriz fila por fila
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
sol = 0  # Acumulador de la suma m√°xima
# recorremos cada fila
for i in range(n):
    ma = 0
    # buscamos el elemento m√°s grande de la fila
    for j in range(m):
        ma = max(ma, a[i][j])
    sol += ma  # sumamos el m√°ximo de la fila al total
print(sol)  # mostramos la suma m√°xima
```

### [Bingo Musical](https://www.hackerrank.com/contests/clase-1-introduccion-y-fundamentos/challenges/bingo-musical)

#### Idea de la soluci√≥n

- Usamos **conjuntos (`set`)** para manejar los n√∫meros de cada jugador.  
- `sol1` guarda los n√∫meros que est√°n en **todas las listas** mediante la **intersecci√≥n** (`&=`).  
- `sol2` guarda los n√∫meros que est√°n en **al menos una lista** mediante la **uni√≥n** (`|=`).  
- Al final imprimimos ambos conjuntos convertidos a cadenas.  

```python
# leemos el n√∫mero de jugadores
n = int(input())
# inicializamos los sets
sol1 = set([i for i in range(1, 1001)])  # para intersecci√≥n: todos los n√∫meros posibles
sol2 = set()                             # para uni√≥n: empieza vac√≠o
# procesamos cada jugador
for i in range(n):
    numeros = list(map(int, input().split()))[1:]  # ignoramos el primer n√∫mero (cantidad)
    set_numeros = set(numeros)                     # convertimos la lista en conjunto
    sol1 &= set_numeros  # intersecci√≥n: n√∫meros que est√°n en todas las listas hasta ahora
    sol2 |= set_numeros  # uni√≥n: n√∫meros que aparecen en al menos una lista
# mostramos el resultado
print(" ".join(map(str, sol1)))  # n√∫meros que aparecen en todas las listas
print(" ".join(map(str, sol2)))  # n√∫meros que aparecen en al menos una lista
```